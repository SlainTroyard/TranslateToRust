# 批量翻译C/C++到Rust功能说明

本项目现已支持批量翻译FuzzForLeetcode中的C/C++代码到Rust，并生成详细的统计报告。该功能可以帮助您批量处理多个LeetCode竞赛题目的代码，并对翻译结果进行多维度分析。

## 功能概述

- **批量翻译**：自动扫描FuzzForLeetcode项目中的所有C/C++代码文件，将它们翻译为Rust代码
- **自动测试**：对翻译后的Rust代码进行编译和测试，验证其正确性
- **多维度统计**：生成详细的统计报告，包括按难度、按语言、按标签、按比赛等多个维度
- **并行处理**：支持多线程并行处理，提高批量翻译的效率
- **可定制化**：支持指定特定比赛、特定题目或特定语言进行翻译
- **资源管理**：系统负载监控和自动调节
- **错误处理**：完善的错误处理和重试机制
- **报告生成**：支持多种格式的测试报告生成

## 如何使用

### 准备工作

在使用批量翻译功能前，请确保：

1. TranslateToRust项目已正确配置，特别是LLM API配置
2. FuzzForLeetcode项目结构完整，包含需要翻译的C/C++代码文件
3. 系统有足够的资源（CPU、内存）用于并行处理

### 使用步骤

1. **设置翻译报告目录**

   ```bash
   cd /home/xiaofan/dev_25/transproj/TranslateToRust/scripts
   ./setup_reports_dir.sh
   ```

2. **运行单个示例**（可选，用于测试）

   ```bash
   # 默认翻译Weekly Contest 413 Problem 1 (CPP)
   ./run_example.sh
   
   # 指定比赛、题目和语言
   ./run_example.sh 413 2 C
   ```

3. **运行批量翻译**

   ```bash
   # 翻译所有C/C++代码
   python batch_translate.py > batch_log.txt 2>&1
   
   # 调整并行线程数
   python batch_translate.py --max-workers 8
   
   # 指定输出目录
   python batch_translate.py --output-dir /path/to/output/dir
   
   # 指定超时时间
   python batch_translate.py --timeout 600
   ```

## 统计报告说明

批量翻译完成后，系统会生成包含以下内容的统计报告：

### 重要说明

在统计报告中，**翻译成功**的定义为：**代码编译成功且通过所有测试用例**。这确保了翻译结果不仅在语法上正确，而且在功能上与原始C/C++代码一致。

### 1. 总体统计

- 总解决方案数量
- C和C++各自的解决方案数量
- 翻译成功率和编译成功率
- 平均处理时间
- 资源使用情况

### 2. 按难度统计 

按照LeetCode题目难度（Easy、Medium、Hard）分类统计：
- 每个难度级别的题目数量
- 翻译成功率和编译成功率
- 测试用例平均通过率
- 平均运行时间
- 错误分布情况

### 3. 按语言统计

比较C和C++代码的：
- 翻译成功率
- 编译成功率
- 测试用例平均通过率
- 平均运行时间
- 常见错误类型

### 4. 按标签统计

按照算法类型和数据结构（如树、图、动态规划等）分类统计：
- 每种类型的题目数量
- 翻译成功率和编译成功率
- 测试用例平均通过率
- 平均运行时间
- 特定类型的错误分析

### 5. 按比赛统计

按照LeetCode周赛分类统计：
- 每场比赛的题目数量
- 翻译成功率和编译成功率
- 测试用例平均通过率
- 平均运行时间
- 比赛难度分布

## 脚本文件说明

- `scripts/batch_translate.py`：主要的批量翻译和测试脚本
- `scripts/batch_test.py`：批量测试已翻译的Rust文件的脚本
- `scripts/generate_test_reports.py`：生成测试报告的脚本
- `scripts/setup_reports_dir.sh`：创建翻译报告目录的脚本
- `scripts/run_example.sh`：运行单个示例的脚本
- `scripts/README.md`：详细的脚本使用说明

## 注意事项

- 批量翻译可能需要较长时间，特别是文件较多时
- 批量翻译过程中可能会消耗大量API调用，请注意API使用成本
- 如果遇到网络问题或API限制，可以考虑减少并行线程数或分批次运行
- 建议定期备份翻译结果和测试报告
- 监控系统资源使用情况，必要时调整并行度

## 资源管理

### 系统负载监控

- CPU使用率监控
- 内存使用情况跟踪
- 磁盘I/O监控
- 网络带宽使用情况

### 自动调节机制

- 系统过载时自动降低并行度
- 资源不足时自动暂停任务
- 动态调整超时时间
- 智能任务调度

### 错误处理

- 自动重试机制
- 错误分类和统计
- 详细的错误日志
- 失败任务恢复

## 最佳实践

1. 资源管理
   - 从较少的工作线程开始（2-4）
   - 执行过程中监控系统资源
   - 根据问题复杂度调整超时时间
   - 定期检查系统负载

2. 测试策略
   - 按相似复杂度分批运行测试
   - 使用适当的超时值
   - 对可能不稳定的测试启用重试
   - 保存中间结果

3. 报告生成
   - 定期生成报告
   - 保留历史数据用于趋势分析
   - 包含失败案例的详细信息
   - 分析错误模式和趋势

## 故障排除

### 常见问题

1. 系统资源问题
   - 减少工作线程数
   - 增加超时时间
   - 监控系统负载
   - 清理临时文件

2. Cargo锁冲突
   - 检查锁文件
   - 清理锁文件
   - 减少并发操作
   - 使用文件锁机制

3. 测试失败
   - 检查编译错误
   - 验证测试用例
   - 调整超时设置
   - 启用重试机制

### 解决方案

1. 性能优化
   - 调整并行度
   - 优化资源使用
   - 改进错误处理
   - 优化测试策略

2. 稳定性提升
   - 完善错误处理
   - 增加重试机制
   - 改进资源管理
   - 优化报告生成

3. 可维护性
   - 完善文档
   - 添加日志
   - 改进代码结构
   - 增加测试覆盖

## 配置示例

```json
{
    "batch_translate": {
        "max_workers": 4,
        "timeout": 600,
        "retry_count": 2,
        "resource_thresholds": {
            "cpu_percent": 80,
            "memory_percent": 80,
            "disk_percent": 90
        }
    },
    "batch_test": {
        "max_workers": 2,
        "timeout": 1800,
        "retry_count": 1,
        "test_categories": ["unit", "integration"]
    },
    "report_generation": {
        "days": 7,
        "format": "markdown",
        "include_details": true,
        "charts": true
    }
}
``` 